# Some part of this code was generated by Open-AI Chat-GPT
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt
import numpy as np
import pickle

from functions import EtoC


# Specify the filename of the pickle file
filename = 'ode_result.pkl'

# Load the `OdeResult` object from the pickle file
with open(filename, 'rb') as file:
    s = pickle.load(file)

# お絵描きする剛体のx幅、y奥行き、z高さ、
xA = 0.5
yA = 0.75
zA = 2.0
vertsA = np.array([[-xA/2, -yA/2, -zA/2],
                  [-xA/2, -yA/2, zA/2],
                  [-xA/2, yA/2, -zA/2],
                  [-xA/2, yA/2, zA/2],
                  [xA/2, -yA/2, -zA/2],
                  [xA/2, -yA/2, zA/2],
                  [xA/2, yA/2, -zA/2],
                  [xA/2, yA/2, zA/2]])
xB = 0.5
yB = 0.75
zB = 2.0
vertsB = np.array([[-xB/2, -yB/2, -zB/2],
                  [-xB/2, -yB/2, zB/2],
                  [-xB/2, yB/2, -zB/2],
                  [-xB/2, yB/2, zB/2],
                  [xB/2, -yB/2, -zB/2],
                  [xB/2, -yB/2, zB/2],
                  [xB/2, yB/2, -zB/2],
                  [xB/2, yB/2, zB/2]])

# Define the 6 faces of the cube
faces = np.array([[0, 1, 3, 2],
                  [0, 4, 5, 1],
                  [0, 2, 6, 4],
                  [1, 5, 7, 3],
                  [2, 3, 7, 6],
                  [4, 6, 7, 5]])

# Define the color of each face
colors = ['blue', 'green', 'red', 'yellow', 'orange', 'purple']

# Set the limits of the plot
xlim = (-2, 2)
ylim = (-2, 2)
zlim = (-4, 1)

# Set up the figure and axes
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.axis('equal')

# Plot the initial cube
cubeA = Poly3DCollection(vertsA[faces], facecolors=colors, alpha=0.25)
cubeB = Poly3DCollection(vertsB[faces], facecolors=colors, alpha=0.25)

ax.add_collection(cubeA)
ax.add_collection(cubeB)

# 剛体Aの Eular parameters の読み出し
E1A = s.y[3,:]
E2A = s.y[4,:]
E3A = s.y[5,:]
E4A = s.y[6,:]

# 剛体Bの Eular parameters の読み出し
E1B = s.y[10,:]
E2B = s.y[11,:]
E3B = s.y[12,:]
E4B = s.y[13,:]

# 剛体Aの位置ベクトルの読み出し
RAx = s.y[0,:]
RAy = s.y[1,:]
RAz = s.y[2,:]

RBx = s.y[7,:]
RBy = s.y[8,:]
RBz = s.y[9,:]

# Define the rotation function
def rotate(i):
    # Define the rotation matrix
    C_OA = EtoC(np.array([E1A[i],E2A[i],E3A[i],E4A[i]]))
    C_OB = EtoC(np.array([E1B[i],E2B[i],E3B[i],E4B[i]]))
    R_OA = np.array([[RAx[i]],[RAy[i]],[RAz[i]]])
    R_OB = np.array([[RBx[i]],[RBy[i]],[RBz[i]]])
    # Rotate the vertices of the cube
    rotated_vertsA = (C_OA @ vertsA.T).T + np.hstack((R_OA,R_OA,R_OA,R_OA,R_OA,R_OA,R_OA,R_OA)).T
    rotated_vertsB = (C_OB @ vertsB.T).T + np.hstack((R_OB,R_OB,R_OB,R_OB,R_OB,R_OB,R_OB,R_OB)).T
    # Update the cube
    cubeA.set_verts(rotated_vertsA[faces])
    cubeB.set_verts(rotated_vertsB[faces])
    # Set the limits of the plot
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_zlim(zlim)
    # Set the labels of the axes
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    

    if i == total_frames - 1:
        ani.event_source.stop()

# Set up the animation
total_frames = len(E1A)
ani = FuncAnimation(fig, rotate, frames=total_frames, interval=16.6)
ax.set_box_aspect((xlim[1]-xlim[0], ylim[1]-ylim[0], zlim[1]-zlim[0]))

# Show the animation
plt.show()

# Save the animation as an MP4 file
ani.save("doubleRigidBodyPendulum.mp4", writer='ffmpeg', fps=60)
print("Animation saved as 'doubleRigidBodyPendulum.mp4'")